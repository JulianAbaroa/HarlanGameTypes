-- Credits to Weesee, Rabid and obviously the MCC Gametypers community.
-- Harlan Forge 1.1
--------------------------------------------------------------------------------
-- HARLAN VERSION: detect harlan_version object for compatibility checks.
-- INIT UPDATE SYSTEM: Allows running code on a forge gametype.
--------------------------------------------------------------------------------
-- UPDATE SYSTEM: Allows running code on a forge gametype.
-- INITIAL ANNOUNCE: Announce welcome messages.
-- CUSTOM TELEPORTS: Converts hill_markers and capture_plates into functional teleports when using the "teleporter" label.
-- QOL TELEPORTS: teleporter waypoints with helpful text.
-- PUSH TELEPORTS: Systems that prevents reciever teleports from being blocked by falcons.
-- QOL FALCON: notify players when falcons have spawned.
-- BLINKSHOT: Players who destroy monitors labeled as "blinkshot" are teleported to their position.
-- SCALE SYSTEM: Allows objects to be scaled in-game.
-- PLAYER INTERFACE: Allows players to interact with internal harlan forge configuration.
-- INVINCIVILITY SYSTEM: Allows players to be invincible whenever they want.
--------------------------------------------------------------------------------
-- DEATH BLINKSHOT: Players who destroy monitors labeled as "blinkshot" are teleported to their position.
--------------------------------------------------------------------------------

alias VERSION = 0

enum map_areas
    nothing = 0
    middle = 1
    valley = 2
    hangar = 3
    sea_red = 4
    sea_blue = 5
    red_base = 6
    blue_base = 7
    centre_island = 8
    up = 9
    down = 10
    bottom = 11
    top = 12
    road_red = 13
    road_blue = 14
end

enum invincibility_mode
    nothing = 0 
    active = 1
    inactive = 2
end

alias all_flags = 0
alias all_falcons = 1

alias ui_alert = script_widget[0]

alias selected_invincibility_mode   = global.number[0]
alias current_calculated_scale      = global.number[1]
alias recursion_counter             = global.number[2]
alias global_math_buffer            = global.number[3]
alias harlan_version                = global.object[0]
alias basis                         = global.object[1]
alias sys_anchor                    = global.object[2]
alias sys_killer                    = global.object[3]
alias sys_interface                 = global.object[4]
alias logic_controller              = global.object[5]
alias selected_interface_team       = global.team[0]

alias announced_game_start          = player.number[0]
alias blinkshot                     = player.object[0]
alias announce_start_timer          = player.timer[2]

alias scale_result                  = object.number[0]
alias invincibility_system          = object.number[0]
alias map_area                      = object.number[0]
alias delay                         = object.number[0]
alias is_blocked                    = object.number[0]
alias math_remainder                = object.number[1]
alias is_prepared                   = object.number[1]
alias send_feedback                 = object.number[1]
alias is_banned                     = object.number[2]
alias prev_spawn_sequece            = object.number[3]
alias linked_teleport               = object.object[0]
alias saved_teleport                = object.object[0]
alias blinkshot                     = object.object[0]
alias spawned_flag                  = object.object[0]
alias killer                        = object.object[0]
alias victim                        = object.object[1]
alias grace_timer                   = object.timer[0]
alias assigned_team                 = object.team[0]

declare selected_invincibility_mode with network priority low
declare current_calculated_scale    with network priority low
declare recursion_counter           with network priority low
declare global_math_buffer          with network priority low
declare harlan_version              with network priority local
declare basis                       with network priority local
declare sys_anchor                  with network priority low
declare sys_killer                  with network priority low
declare sys_interface               with network priority low
declare logic_controller            with network priority low
declare selected_interface_team     with network priority low

declare player.announced_game_start with network priority low
declare player.announce_start_timer = 5

on init: do
    ----------------------------------------------------------------------------
    -- INIT UPDATE SYSTEM:
    -- Allows running code on a forge gametype.
    ----------------------------------------------------------------------------
    function reset_anchor_pos()
        sys_anchor.victim.detach()

        sys_anchor.attach_to(sys_anchor.victim, 0, 0, 0, absolute)
        sys_anchor.detach()
    end

    function step_up_sequence()
        sys_anchor.victim.attach_to(sys_anchor, 0, 0, 127, absolute)
        reset_anchor_pos()

        sys_anchor.victim.attach_to(sys_anchor, 0, 0, 127, absolute)
        reset_anchor_pos()
    end

    -- We search for or create the Anchor (Logic Controller)
    for each object do
        if basis == no_object then
            basis = current_object
        end
    end

    for each player do
        if sys_anchor == no_object then
            -- Now we create the real Anchor
            sys_anchor = basis.place_at_me(flag_stand, none, never_garbage_collect, 0, 0, 127, none)
    
            -- We begin the cycle of life and death
            sys_anchor.victim = sys_anchor.place_at_me(monitor, "sys_victim", never_garbage_collect, 0, 0, 0, none)
    
            -- Positioning
            sys_anchor.attach_to(sys_anchor.victim, 0, 0, 0, absolute)
            sys_anchor.detach()

            step_up_sequence()
            step_up_sequence()
            step_up_sequence()

            sys_anchor.victim.attach_to(sys_anchor, 0, 0, 100, absolute)
            reset_anchor_pos()

            sys_anchor.killer = sys_anchor.victim.place_at_me(kill_ball, none, none, 0, 0, 0, none)
            sys_anchor.killer.attach_to(sys_anchor.victim, 0, 0, 0, relative)

            sys_anchor.victim = sys_anchor.place_at_me(monitor, "sys_victim", none, 0, 0, 0, none)

            -- Initialization of logic controller.
            logic_controller = sys_anchor   
        end
    end
end

-- We use the 'on object death: do' event as our update function.
on object death: do
    ----------------------------------------------------------------------------
    -- HARLAN VERSION:
    -- detect harlan_version object for compatibility checks.
    ----------------------------------------------------------------------------
    harlan_version = no_object
    for each object with label "harlan_version" do
        harlan_version = current_object
    end
    
    ----------------------------------------------------------------------------
    -- UPDATE SYSTEM:
    -- Allows running code on a forge gametype.
    ----------------------------------------------------------------------------
    if killed_object.is_of_type(monitor) and killed_object.has_forge_label("sys_victim") then
        -- If the anchor exists, we create a new victim.
        if sys_anchor != no_object then
            if sys_anchor.killer != no_object then
                sys_anchor.killer.delete()
            end

            -- 2. We created the new victim at the Anchor
            sys_anchor.victim = sys_anchor.place_at_me(monitor, "sys_victim", none, 0, 0, 0, none)

            -- 3. We created the new Kill Ball
            sys_anchor.killer = sys_anchor.victim.place_at_me(kill_ball, none, none, 0, 0, 0, none)

            -- 4. We hit her to kill the victim in the next physical frame
            sys_anchor.killer.attach_to(sys_anchor.victim, 0, 0, 0, absolute)
        end
    end

    ----------------------------------------------------------------------------
    -- INITIAL ANNOUNCE:
    -- Announce welcome messages.
    ----------------------------------------------------------------------------
    for each player do
        current_player.announce_start_timer.set_rate(-100%)

        if current_player.announced_game_start == 0 then
            -- TODO: Doesn't show up for some reason.
            ui_alert.set_text("IN MEMORY OF THE HARLAN")
            ui_alert.set_visibility(current_player, true)

            if current_player.announce_start_timer.is_zero() then
                game.show_message_to(current_player, none, "Version 2.0.%n by Place & Art", VERSION)

                if harlan_version != no_object then
                    if harlan_version.spawn_sequence == 0 then
                        game.show_message_to(current_player, none, "Harlan Forge")
                    alt
                        game.show_message_to(current_player, none, "WARNING: Map expects newer version of this gametype")
                    end
                end

                current_player.announced_game_start = 1
                ui_alert.set_visibility(current_player, false)
            end

        end
    end
    
    ----------------------------------------------------------------------------
    -- CUSTOM TELEPORTS:
    -- Converts hill_markers and capture_plates into functional teleports when using the "teleporter" label.
    ----------------------------------------------------------------------------
    for each object with label "teleporter" do
        alias c_teleport = current_object

        -- If this object meets the requirements to be a custom teleport.
        if  c_teleport.spawn_sequence > 0 
        and c_teleport.is_of_type(hill_marker) 
        or c_teleport.is_of_type(capture_plate)
        then
            c_teleport.set_waypoint_range(0, 10)
            c_teleport.set_waypoint_visibility(everyone)
            c_teleport.set_waypoint_priority(low)   

            if c_teleport.is_of_type(hill_marker) then
                c_teleport.set_shape_visibility(everyone)  
                    
            altif c_teleport.is_of_type(capture_plate) then
                c_teleport.set_shape_visibility(no_one)
            end
        end
    end

    -- This code below links custom teleports that have the same spawn_sequence.
    for each object with label "teleporter" do
        alias c_teleport = allocate temporary object
        c_teleport = current_object

        if  c_teleport.spawn_sequence > 0 
        and c_teleport.is_of_type(hill_marker) 
        or c_teleport.is_of_type(capture_plate)
        then
            for each object with label "teleporter" do
                alias temp_teleport = current_object  

                if c_teleport.spawn_sequence > 0 
                and temp_teleport.is_of_type(hill_marker) 
                or temp_teleport.is_of_type(capture_plate)
                then
                    -- If these teleports are not the same one.
                    if temp_teleport != c_teleport then
                        if temp_teleport.spawn_sequence == c_teleport.spawn_sequence then
                            -- Team-based linking only for new maps with harlan_version
                            if harlan_version != no_object then
                                if temp_teleport.team == c_teleport.team then
                                    c_teleport.linked_teleport = temp_teleport
                                    temp_teleport.linked_teleport = c_teleport
                                end
                            alt
                                -- Legacy mode: link by spawn_sequence only
                                c_teleport.linked_teleport = temp_teleport
                                temp_teleport.linked_teleport = c_teleport
                            end
                        end
                    end
                end
            end
        end
    end

    -- This code below cleans those custom teleports that are linked when if they have different spawn_sequences
    for each object with label "teleporter" do
        alias c_teleport = current_object

        if  c_teleport.spawn_sequence > 0 
        and c_teleport.is_of_type(hill_marker) 
        and c_teleport.linked_teleport != no_object
        then
            alias temp_teleport = allocate temporary object
            temp_teleport = c_teleport.linked_teleport

            if c_teleport.spawn_sequence != temp_teleport.spawn_sequence then
                c_teleport.linked_teleport = no_object
            end
        end
    end

    -- This code below is the main logic of custom teleports.
    for each object with label "teleporter" do
        alias c_teleport = current_object

        if c_teleport.spawn_sequence > 0
        and c_teleport.is_of_type(hill_marker)
        and c_teleport.linked_teleport != no_object
        and c_teleport.linked_teleport.has_forge_label("teleporter")
        and c_teleport.linked_teleport.is_of_type(hill_marker)
        or c_teleport.linked_teleport.is_of_type(capture_plate)
        then
            for each player do
                alias c_player = current_player
                alias c_biped = allocate temporary object
                c_biped = c_player.biped

                -- If a player has entered this custom teleport.
                if c_teleport.shape_contains(c_biped) and c_biped.saved_teleport == no_object then
                    alias c_weapon = allocate temporary object
                    c_weapon = c_player.get_weapon(primary)

                    -- If this player has a flag.
                    if c_weapon.is_of_type(flag) then
                        -- If the custom teleport and the flag are from the same team.
                        if c_teleport.team == c_weapon.team or c_teleport.team == neutral_team then
                            c_biped.attach_to(c_teleport.linked_teleport, 0, 0, 0, relative)
                            c_biped.saved_teleport = c_teleport.linked_teleport
                        end
                    
                    -- If this player doesn't have a flag.
                    altif not c_weapon.is_of_type(flag) then
                        c_biped.attach_to(c_teleport.linked_teleport, 0, 0, 0, relative)
                        c_biped.saved_teleport = c_teleport.linked_teleport
                    end
                end
                            
                --If this player has a saved teleport
                if c_biped.saved_teleport != no_object then
                    -- If this player is not inside the saved teleport's shape.
                    if not c_biped.saved_teleport.shape_contains(c_biped) then
                        c_biped.saved_teleport = no_object
                        c_biped.delay = 0
                    end
        
                    c_biped.delay += 1
            
                    if c_biped.delay == 50 then
                        c_biped.detach()
                        c_biped.delay = 0
                    end
                end
            end
        end
    end

    ----------------------------------------------------------------------------
    -- QOL TELEPORTS:
    -- teleporter waypoints with helpful text.
    ----------------------------------------------------------------------------
    for each object with label "teleporter" do
        alias c_teleport = current_object
        alias show_text = allocate temporary number
        show_text = 1

        if not c_teleport.is_of_type(capture_plate) then
            -- Check if this is a bidirectional pair
            if c_teleport.is_of_type(hill_marker) 
            and c_teleport.linked_teleport != no_object 
            and c_teleport.linked_teleport.is_of_type(hill_marker)
            then
                show_text = 0
            end

            if  c_teleport.spawn_sequence >= 0
            and harlan_version != no_object
            and harlan_version.spawn_sequence < 1 
            and show_text == 1 
            then
                -- Shape
                c_teleport.set_shape_visibility(everyone)
        
                -- Waypoint
                c_teleport.set_waypoint_visibility(everyone)
                c_teleport.set_waypoint_priority(low)
                c_teleport.set_waypoint_range(0, 20)
        
                if c_teleport.spawn_sequence == map_areas.middle 
                and c_teleport.map_area != map_areas.middle 
                then
                    c_teleport.set_waypoint_text("Middle")
                    c_teleport.map_area = map_areas.middle

                altif c_teleport.spawn_sequence == map_areas.valley 
                and c_teleport.map_area != map_areas.valley 
                then
                    c_teleport.set_waypoint_text("Valley")
                    c_teleport.map_area = map_areas.valley
                    
                altif c_teleport.spawn_sequence == map_areas.hangar 
                and c_teleport.map_area != map_areas.hangar 
                then
                    c_teleport.set_waypoint_text("Hangar")
                    c_teleport.map_area = map_areas.hangar

                altif c_teleport.spawn_sequence == map_areas.sea_red 
                and c_teleport.map_area != map_areas.sea_red 
                then
                    c_teleport.set_waypoint_text("Sea Red")
                    c_teleport.map_area = map_areas.sea_red

                altif c_teleport.spawn_sequence == map_areas.sea_blue 
                and c_teleport.map_area != map_areas.sea_blue 
                then
                    c_teleport.set_waypoint_text("Sea Blue")
                    c_teleport.map_area = map_areas.sea_blue

                altif c_teleport.spawn_sequence == map_areas.red_base 
                and c_teleport.map_area != map_areas.red_base 
                then
                    c_teleport.set_waypoint_text("Red Base")
                    c_teleport.map_area = map_areas.red_base

                altif c_teleport.spawn_sequence == map_areas.blue_base 
                and c_teleport.map_area != map_areas.blue_base 
                then
                    c_teleport.set_waypoint_text("Blue Base")
                    c_teleport.map_area = map_areas.blue_base

                altif c_teleport.spawn_sequence == map_areas.centre_island 
                and c_teleport.map_area != map_areas.centre_island 
                then
                    c_teleport.set_waypoint_text("Island")
                    c_teleport.map_area = map_areas.centre_island
                        
                altif c_teleport.spawn_sequence == map_areas.up 
                and c_teleport.map_area != map_areas.up 
                then
                    c_teleport.set_waypoint_text("Up")
                    c_teleport.map_area = map_areas.up
                
                altif c_teleport.spawn_sequence == map_areas.down 
                and c_teleport.map_area != map_areas.down 
                then
                    c_teleport.set_waypoint_text("Down")
                    c_teleport.map_area = map_areas.down
                
                altif c_teleport.spawn_sequence == map_areas.bottom 
                and c_teleport.map_area != map_areas.bottom 
                then
                    c_teleport.set_waypoint_text("Bottom")
                    c_teleport.map_area = map_areas.bottom

                altif c_teleport.spawn_sequence == map_areas.top 
                and c_teleport.map_area != map_areas.top 
                then
                        c_teleport.set_waypoint_text("Top")

                altif c_teleport.spawn_sequence == map_areas.road_red 
                and c_teleport.map_area != map_areas.road_red 
                then
                    c_teleport.set_waypoint_text("Road Red")

                altif c_teleport.spawn_sequence == map_areas.road_blue 
                and c_teleport.map_area != map_areas.road_blue 
                then
                    c_teleport.set_waypoint_text("Road Blue")
                end
        
                if c_teleport.spawn_sequence < map_areas.middle 
                or c_teleport.spawn_sequence > map_areas.road_blue 
                then
                    c_teleport.set_waypoint_visibility(no_one)
                    c_teleport.map_area = map_areas.nothing
                end

            alt 
                c_teleport.set_waypoint_text("")
            end
        end
    end

    ----------------------------------------------------------------------------
    -- PUSH TELEPORTS: 
    -- Systems that prevents reciever teleports from being blocked by falcons.
    ----------------------------------------------------------------------------
    for each object with label "push_receiver" do
        alias c_receiver = current_object

        c_receiver.is_blocked = 0
        c_receiver.set_shape(cylinder, 20, 15, 0)
        c_receiver.set_waypoint_range(0, 20)
        c_receiver.set_waypoint_text("Do not block!")

        if c_receiver.send_feedback == 0 then
            game.show_message_to(all_players, none, "Push teleport setted")
            c_receiver.send_feedback = 1
        end
    end

    for each object with label all_falcons do
        alias c_falcon = allocate temporary object
        c_falcon = current_object

        if c_falcon.is_prepared == 0 then
            c_falcon.is_prepared = 1

            c_falcon.grace_timer.set_rate(0%)
            c_falcon.grace_timer = 0
            c_falcon.is_banned = 0
        end

        alias is_blocking = allocate temporary number
        is_blocking = 0

        for each object with label "push_receiver" do
            alias c_receiver = current_object

            if c_receiver.shape_contains(c_falcon) then
                c_falcon.grace_timer.set_rate(100%)
                c_receiver.is_blocked = 1
                is_blocking = 1

                if c_falcon.grace_timer >= 15 or c_falcon.is_banned == 1 then
                    c_falcon.apply_upward_impulse()
                    c_falcon.is_banned = 1
                end
            end
        end

        if is_blocking == 0 then
            c_falcon.grace_timer.set_rate(0%)
            c_falcon.grace_timer = 0
        end
    end

    -- Visual feedback
    for each object with label "push_receiver" do
        alias c_receiver = current_object

        if c_receiver.is_blocked == 1 then
            c_receiver.set_shape_visibility(everyone)
            c_receiver.set_waypoint_priority(blink)
            c_receiver.set_waypoint_visibility(everyone)

        altif c_receiver.is_blocked == 0 then
            c_receiver.set_shape_visibility(no_one)
            c_receiver.set_waypoint_priority(normal)
            c_receiver.set_waypoint_visibility(no_one)
        end
    end

    --------------------------------------------------------------------------------
    -- QOL FALCON:
    -- notify players when falcons have spawned.
    --------------------------------------------------------------------------------
    if harlan_version != no_object and harlan_version.spawn_sequence < 1 then
        for each object with label all_falcons do
            alias c_falcon = current_object

            -- To avoid show_message_to() spamming.
            if not c_falcon.has_forge_label("scale") then
                if c_falcon.spawn_sequence == map_areas.middle and c_falcon.map_area != map_areas.middle then
                    game.show_message_to(all_players, none, "Middle falcon setted")
                    c_falcon.map_area = map_areas.middle
        
                altif c_falcon.spawn_sequence == map_areas.valley and c_falcon.map_area != map_areas.valley then
                    game.show_message_to(all_players, none, "Valley falcon setted")
                    c_falcon.map_area = map_areas.valley
        
                altif c_falcon.spawn_sequence == map_areas.hangar and c_falcon.map_area != map_areas.hangar then
                    game.show_message_to(all_players, none, "Hangar falcon setted")
                    c_falcon.map_area = map_areas.hangar
                
                altif c_falcon.spawn_sequence == map_areas.sea_red and c_falcon.map_area != map_areas.sea_red then
                    game.show_message_to(all_players, none, "Sea red falcon setted")
                    c_falcon.map_area = map_areas.sea_red
        
                altif c_falcon.spawn_sequence == map_areas.sea_blue and c_falcon.map_area != map_areas.sea_blue then
                    game.show_message_to(all_players, none, "Sea blue falcon setted")
                    c_falcon.map_area = map_areas.sea_blue
        
                altif c_falcon.spawn_sequence == map_areas.red_base and c_falcon.map_area != map_areas.red_base then
                    game.show_message_to(all_players, none, "Red base falcon setted")
                    c_falcon.map_area = map_areas.red_base
        
                altif c_falcon.spawn_sequence == map_areas.blue_base and c_falcon.map_area != map_areas.blue_base then
                    game.show_message_to(all_players, none, "Blue base falcon setted")
                    c_falcon.map_area = map_areas.blue_base

                altif c_falcon.spawn_sequence == map_areas.centre_island and c_falcon.map_area != map_areas.centre_island then
                    game.show_message_to(all_players, none, "Island falcon setted")
                    c_falcon.map_area = map_areas.centre_island
                end

                if c_falcon.spawn_sequence < map_areas.middle or c_falcon.spawn_sequence > map_areas.centre_island then
                    if c_falcon.map_area != map_areas.nothing then
                        game.show_message_to(all_players, none, "No area selected for this falcon")
                    end

                    c_falcon.map_area = map_areas.nothing
                end
            end
        end
    end

    --------------------------------------------------------------------------------
    -- BLINKSHOT:
    -- Players who destroy monitors labeled as "blinkshot" are teleported to their position.
    --------------------------------------------------------------------------------
    for each object with label "blink_spawn" do
        alias blink_spawn = current_object

        -- Used 'spawn_sequence' to allow players to decide if the blinkshot is going to be spawned or not.
        if  blink_spawn.spawn_sequence == 1 and 
            blink_spawn.blinkshot == no_object
        then
            blink_spawn.blinkshot = blink_spawn.place_at_me(monitor, "blinkshot", none, 0, 0, 0, none)
            blink_spawn.blinkshot.set_scale(150)
            blink_spawn.blinkshot.set_waypoint_priority(low)
            blink_spawn.blinkshot.set_waypoint_visibility(everyone)
            blink_spawn.blinkshot.set_waypoint_range(0, 100)
        end
    end

    for each object with label "blinkshot" do
        alias blinkshot = current_object
        blinkshot.shields = 0
        blinkshot.health = 1
    end

    for each player do
        alias c_player = current_player
        alias killed_blink = allocate temporary object
        killed_blink = c_player.blinkshot

        if killed_blink != no_object and killed_blink.has_forge_label("blinkshot") then
            alias c_weapon = allocate temporary object
            c_weapon = c_player.get_weapon(primary)

            if c_weapon.is_of_type(flag) then
                killed_blink.delete()
            end

            c_player.biped.attach_to(killed_blink, 0, 0, 0, relative)
            c_player.biped.shields = 0

            killed_blink.delay += 1
            if killed_blink.delay >= 40 then
                c_player.biped.detach()
                killed_blink.delete()
            end
        end
    end

    --------------------------------------------------------------------------------
    -- CAPTURE THE FLAG:
    -- System that spawns flag on flag stands positions based on its selected team.
    --------------------------------------------------------------------------------
    for each object with label "ctf_flag_return" do
        alias c_flag_stand = current_object

        -- If this object is a flag stand.
        if c_flag_stand.is_of_type(flag_stand) then
            if c_flag_stand.team != c_flag_stand.assigned_team then
                c_flag_stand.spawned_flag.delete()
            end

            -- If this flag stand doesn't have a spawned flag.
            if c_flag_stand.spawned_flag == no_object then
                alias new_flag = allocate global.object

                -- If this flag stand is from red team.
                if c_flag_stand.team == team[0] then
                   new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                   new_flag.team = team[0]

                -- If this flag stand is from blue team.
                altif c_flag_stand.team == team[1] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[1]

                altif c_flag_stand.team == team[2] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[2]

                altif c_flag_stand.team == team[3] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[3]

                altif c_flag_stand.team == team[4] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[4]

                altif c_flag_stand.team == team[5] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[5]

                altif c_flag_stand.team == team[6] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[6]

                altif c_flag_stand.team == team[7] then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = team[7]

                altif c_flag_stand.team == neutral_team then
                    new_flag = c_flag_stand.place_at_me(flag, none, none, 0, 0, 0, none)
                    new_flag.team = neutral_team
                end

                if new_flag != no_object then
                    c_flag_stand.spawned_flag = new_flag
                end

                c_flag_stand.assigned_team = c_flag_stand.team
            end
        end
    end

    ----------------------------------------------------------------------------
    -- SCALE SYSTEM:
    -- Allows objects to be scaled in-game.
    ----------------------------------------------------------------------------
    if harlan_version != no_object and harlan_version.spawn_sequence < 1 then
        function math_precision_calculator()
            alias subject = current_object

            -- We increment the recursion counter to avoid infinite loops.
            recursion_counter += 1

            -- Start of the mathematical smoothing algorithm:
            -- It takes the current size and saves it in the waste buffer.
            subject.math_remainder = subject.scale_result

            -- Divide the remainder by 33 (simulate 3%).
            subject.math_remainder /= 33

            -- It takes the current size, passes it to the global buffer and divides it by 228 (simulating 0.4%).
            global_math_buffer = subject.scale_result
            global_math_buffer /= 228

            -- Add both fractional results to the total size.
            -- This creates compound growth with each iteration.
            subject.scale_result += subject.math_remainder
            subject.scale_result += global_math_buffer

            -- If the recursion counter has not yet reached the limit defined in current_calculated_scale...
            if recursion_counter < current_calculated_scale then
                -- ...it calls itself to continue calculating.
                math_precision_calculator()
            end
        end

        for each object with label "scale" do
            alias subject = current_object

            -- We initialize the current scale with the value of the Spawn Sequence.
            current_calculated_scale = subject.spawn_sequence

            -- Initial base of 100%
            subject.scale_result = 100
            current_calculated_scale = subject.spawn_sequence

            -- If it is negative, we apply a multiplier of x5
            if subject.spawn_sequence < 0 then
                current_calculated_scale *= 5
                subject.scale_result += current_calculated_scale

                -- Special case: Spawn Sequence -20 strength scales to 1%
                if subject.spawn_sequence == -20 then
                    subject.scale_result = 1
                end

                -- Special calculation for values ​​less than -20
                if subject.spawn_sequence < -20 then
                    current_calculated_scale = 100
                    current_calculated_scale += subject.spawn_sequence
                    current_calculated_scale += 101
                end
            end

            -- If it is outside the safe range (-20 to 0), we activate recursion.
            if subject.spawn_sequence < -20 or subject.spawn_sequence > 0 then
                subject.scale_result = 100
                    
                -- Reset global counter
                recursion_counter = 0

                math_precision_calculator()
            end

            -- We assign the final calculated result to the current value
            current_calculated_scale = subject.scale_result

            -- We save the final calculation in the object's memory for future reference.
            subject.scale_result = current_calculated_scale

            -- We performed the actual resizing in the game engine.
            subject.set_scale(current_calculated_scale)

            -- We copy rotation on itself to force the physics update.
            subject.copy_rotation_from(subject, false)
        end
    end

    ----------------------------------------------------------------------------
    -- PLAYER INTERFACE:
    -- Allows players to interact with internal harlan forge configuration.
    ----------------------------------------------------------------------------
    if sys_interface == no_object then
        for each object with label "sys_config" do
            alias interface = current_object

            if interface.is_of_type(flag_stand)then
                sys_interface = interface            
            end
        end
    end 

    if sys_interface != no_object 
    and sys_interface.has_forge_label("sys_config") 
    then
        -- If the selected team is red and it wasn't red team before.
        if sys_interface.team == team[0] then
            if selected_interface_team != team[0] then
                -- Save the selected team as red team.
                selected_interface_team = team[0]
                game.show_message_to(all_players, none, "Change invincibility mode active")
            end

            if sys_interface.spawn_sequence == invincibility_mode.active 
            and selected_invincibility_mode != invincibility_mode.active
            then
                game.show_message_to(all_players, none, "Invincibility mode active")
                logic_controller.invincibility_system = invincibility_mode.active
                selected_invincibility_mode = invincibility_mode.active

            altif sys_interface.spawn_sequence == invincibility_mode.inactive 
            and selected_invincibility_mode != invincibility_mode.inactive
            then
                game.show_message_to(all_players, none, "Invincibility mode inactive")
                logic_controller.invincibility_system = invincibility_mode.inactive
                selected_invincibility_mode = invincibility_mode.inactive

            -- If it's not any mode of invincibility, reset the selected invincibility mode.
            altif sys_interface.spawn_sequence != invincibility_mode.active 
            and sys_interface.spawn_sequence != invincibility_mode.inactive
            then
                selected_invincibility_mode = invincibility_mode.nothing
            end

        -- Reset the system selected
        altif sys_interface.team != team[0] 
        and selected_interface_team != no_team 
        then
            selected_interface_team = no_team
            game.show_message_to(all_players, none, "No system selected")
        end

    -- if it's not any team, reset the selected team
    altif sys_interface.team != team[0] 
    and selected_interface_team != no_team 
    then
        selected_interface_team = no_team
    end

    ----------------------------------------------------------------------------
    -- INVINCIVILITY SYSTEM:
    --  Allows players to be invincible whenever they want.
    ----------------------------------------------------------------------------
    if logic_controller.invincibility_system != invincibility_mode.nothing then
        for each player do
            alias c_player = current_player

            -- If the invincibility should be active.
            if logic_controller.invincibility_system == invincibility_mode.active then
                c_player.biped.set_invincibility(1)

            altif logic_controller.invincibility_system == invincibility_mode.inactive then
                c_player.biped.set_invincibility(0)
            end
        end
    end
    
    -- If the killer was a player.
    if killer_player != no_player then
        alias c_vehicle = allocate temporary object
        c_vehicle = killer_player.get_vehicle()
        
        -- If the player didn't had a vehicle.
        if c_vehicle == no_object then
            --------------------------------------------------------------------
            -- DEATH BLINKSHOT:
            -- Players who destroy monitors labeled as "blinkshot" are teleported to their position.
            --------------------------------------------------------------------
            if killed_object.has_forge_label("blinkshot") then
                killer_player.blinkshot = killed_object.place_at_me(hill_marker, "blinkshot", none, 0, 0, 0, none)
            end
        end
    end
end