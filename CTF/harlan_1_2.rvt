-- Credits to Weesee, Rabid and obviously the MCC Gametypers community.

-- Capture the Flag uses:

-- Declarations:

-- global.number[0-4]
-- global.object[0-1]
-- global.player[0-1]
-- global.team[0]
-- player.number[0-1]
-- player.timer[0-2]
-- team.object[0-1]


-- Harlan 1.2 uses:

-- Declarations:

-- global.object[2]
-- global.number[5-8]

-- Aliases:

-- Scale System:

-- Every object that uses the scale label, has its number[0-1] occupied.
-- scale_result = object.number[0].
-- math_remainder = object.number[1].

-- logic_controller object has its number[0] occupied by the selected scale system mode.
-- scale_system = object.number[0].

-- QoL Falcon:

-- Every falcon has its number[0] occupied.
-- spawn_announced = object.number[0].

-- Custom Teleports:

-- Every object of type hill_marker & capture_plate and with the
-- label "teleporter" has its object[0] occupied.
-- linked_teleport = object.object[0].

-- Every player biped, while using a custom teleport, 
-- has ocuppied its object[0] & number[0].
-- saved_teleport = object.object[0].
-- delay = object.number[0].

-- Push Teleports:

-- Every object with the label "teleporter" & spawn_sequence == -1
-- has its number[0] occupied.
-- is_blocked = object.number[0].

-- Every falcon has its number[1-2] & timer[0] occupied.
-- initialized = object.number[1].
-- is_banned = object.number[2].
-- grace_timer = object.timer[0].

-- Blinkshot:

-- Every object of type hill_marker & with the label "blink_spawn" .
-- has occupied its object[0].
-- blinkshot = object.object[0].

-- Every player, while using blinkshots, has occupied its object[0].
-- blinkshot = player.object[0].

-- Every killed_blink has occupied its number[0].
-- delay = object.number[0].

-- Betrayers Handler:

-- Every player has occupied its number[2].
-- betrayals = player.number[2].

-- Comms:

-- Every object of type hill_marker & with the label "comms"
-- has occupied its object[0-1].
-- linked_comms = object.object[0].
-- instance = object.object[1].





-- Declarations

declare global.object[2] with network priority low
alias logic_controller = global.object[2]

declare global.number[5] with network priority low
alias current_calculated_scale = global.number[5]

declare global.number[6] with network priority low
alias recursion_counter = global.number[6]

-- Prob this can be allocated and not global declaration.
declare global.number[7] with network priority low
alias global_math_buffer = global.number[7]

-- QoL teleports.
declare global.number[8] with network priority low
alias c_round = global.number[8]

-- Declarations





-- Scale system

-- Properties of the Object being scaled
-- scale_result: Store the final % (e.g., 100, 200, 50) before applying it.
alias scale_result = object.number[0]

-- math_remainder: Stores division residues for high-precision simulations.
alias math_remainder = object.number[1]

-- scale_system: Define which formula to use (0=Nothing, 1=lineal, 2=x10, 3=high_precision).
-- This is read from the controller object (logic_controller).
alias scale_system = object.number[0]

enum scale_mode
    nothing = 0
    lineal = 1
    x10 = 2
    high_precision = 3
end

function initialize_logic_controller()
    for each object with label "logic_controller" do
        if logic_controller == no_object then
            logic_controller = current_object
        end
    end

    alias scale_mode_option = script_option[7]
    if scale_mode_option == scale_mode.nothing then
        logic_controller.scale_system = scale_mode.nothing
    
    altif scale_mode_option == scale_mode.lineal then
        logic_controller.scale_system = scale_mode.lineal

    altif scale_mode_option == scale_mode.x10 then
        logic_controller.scale_system = scale_mode.x10

    altif scale_mode_option == scale_mode.high_precision then
        logic_controller.scale_system = scale_mode.high_precision
    end
end

function math_precision_calculator()
    alias subject = current_object

    -- We increment the recursion counter to avoid infinite loops.
    recursion_counter += 1

    -- Start of the mathematical smoothing algorithm:
    -- It takes the current size and saves it in the waste buffer.
    subject.math_remainder = subject.scale_result

    -- Divide the remainder by 33 (simulate 3%).
    subject.math_remainder /= 33

    -- It takes the current size, passes it to the global buffer and divides it by 228 (simulating 0.4%).
    global_math_buffer = subject.scale_result
    global_math_buffer /= 228

    -- Add both fractional results to the total size.
    -- This creates compound growth with each iteration.
    subject.scale_result += subject.math_remainder
    subject.scale_result += global_math_buffer

    -- If the recursion counter has not yet reached the limit defined in current_calculated_scale...
    if recursion_counter < current_calculated_scale then
        -- ...it calls itself to continue calculating.
        math_precision_calculator()
    end
end

function limit_checker()
    alias subject = current_object

    -- If the spawn_sequence is exactly -10, force minimum scale.
    if subject.spawn_sequence == -10 then
        current_calculated_scale = 1
    end
end

function scaling_system()
    if logic_controller == no_object then
        initialize_logic_controller()
    end
    
    for each object with label "scale" do
        alias subject = current_object

        -- We initialize the current scale with the value of the Spawn Sequence.
        current_calculated_scale = subject.spawn_sequence

        -- Mode 0: Lineal
        if logic_controller.scale_system == scale_mode.lineal then
            -- If the spawn sequence is negative (e.g., -15), apply the expansion formula.
            if subject.spawn_sequence < -10 then
                -- Formula: (x + 101) * 2
                current_calculated_scale += 101
                current_calculated_scale *= 2

                -- Fine adjustments according to specific negative ranges:
                if subject.spawn_sequence > -71 then
                    current_calculated_scale *= 2
                end

                if subject.spawn_sequence > -41 then
                    -- Equivalent to multiplying by 1.5
                    current_calculated_scale *= 3
                    current_calculated_scale /= 2 
                end
            end

            -- Final conversion to base percentage: (x * 10) + 100
            current_calculated_scale *= 10
            current_calculated_scale += 100

            -- Offset settings for large negative values
            if subject.spawn_sequence < -10 then
                current_calculated_scale += 1000

                if subject.spawn_sequence > -71 then
                    current_calculated_scale += -600
                end

                if subject.spawn_sequence > -41 then
                    current_calculated_scale += -1200
                end
            end

            -- Check if we fell into the forbidden value (-10)
            limit_checker()
        end

        -- Mode 1: x10 Multiplier
        if logic_controller.scale_system == scale_mode.x10 then
            current_calculated_scale *= 10

            if subject.spawn_sequence < -10 then
                current_calculated_scale *= 2

                if subject.spawn_sequence > -81 then
                    current_calculated_scale += 800
                end
            end

            if subject.spawn_sequence < -80 then
                current_calculated_scale *= 2
                current_calculated_scale += -800
            end

            current_calculated_scale += 100
            limit_checker()
        end

        -- Mode 3: High Precision
        if logic_controller.scale_system == scale_mode.high_precision then
            -- Initial base of 100%
            subject.scale_result = 100
            current_calculated_scale = subject.spawn_sequence

            -- If it is negative, we apply a multiplier of x5
            if subject.spawn_sequence < 0 then
                current_calculated_scale *= 5
                subject.scale_result += current_calculated_scale

                -- Special case: Spawn Sequence -20 strength scales to 1%
                if subject.spawn_sequence == -20 then
                    subject.scale_result = 1
                end

                -- Special calculation for values ​​less than -20
                if subject.spawn_sequence < -20 then
                    current_calculated_scale = 100
                    current_calculated_scale += subject.spawn_sequence
                    current_calculated_scale += 101
                end
            end

            -- If it is outside the safe range (-20 to 0), we activate recursion.
            if subject.spawn_sequence < -20 or subject.spawn_sequence > 0 then
                subject.scale_result = 100
                
                -- Reset global counter
                recursion_counter = 0

                math_precision_calculator()
            end

            -- We assign the final calculated result to the current value
            current_calculated_scale = subject.scale_result
        end

        -- We save the final calculation in the object's memory for future reference.
        subject.scale_result = current_calculated_scale

        -- We performed the actual resizing in the game engine.
        subject.set_scale(current_calculated_scale)

        -- We copy rotation on itself to force the physics update.
        subject.copy_rotation_from(subject, false)
    end
end

-- Scale system





-- QoL Falcon.

alias spawn_announced = object.number[0]

enum map_areas
    nothing = 0
    middle = 1
    valley = 2
    hangar = 3
    sea_red = 4
    sea_blue = 5
    red_base = 6
    blue_base = 7
    centre_island = 8
    up = 9
    down = 10
    bottom = 11
end

function qol_falcon()
    -- For each falcon do
    for each object with label 1 do
        alias c_falcon = current_object

        inline: if c_falcon.spawn_announced == 0 then
            c_falcon.spawn_announced = 1

            inline: if c_falcon.spawn_sequence == map_areas.middle then
                game.show_message_to(all_players, none, "Falcon spawned in Middle")
                
            inline: altif c_falcon.spawn_sequence == map_areas.valley then
                game.show_message_to(all_players, none, "Falcon spawned in Valley")   

            inline: altif c_falcon.spawn_sequence == map_areas.hangar then
                game.show_message_to(all_players, none, "Falcon spawned in Hangar")  
                    
            inline: altif c_falcon.spawn_sequence == map_areas.sea_red then
                game.show_message_to(all_players, none, "Falcon spawned in Sea Red")   

            inline: altif c_falcon.spawn_sequence == map_areas.sea_blue then
                game.show_message_to(all_players, none, "Falcon spawned in Sea Blue")

            inline: altif c_falcon.spawn_sequence == map_areas.red_base then
                game.show_message_to(all_players, none, "Falcon spawned in Red Base")

            inline: altif c_falcon.spawn_sequence == map_areas.blue_base then
                game.show_message_to(all_players, none, "Falcon spawned in Blue Base")

            inline: altif c_falcon.spawn_sequence == map_areas.centre_island then
                game.show_message_to(all_players, none, "Falcon spawned in Island")
            end
        end
    end
end

-- QoL Falcon.





-- QoL Teleports.

function qol_teleports()
    c_round = game.current_round
    c_round %= 2 -- Is round odd

    for each object with label "teleporter" do
        alias c_teleport = current_object

        inline: if not c_teleport.is_of_type(capture_plate) and not c_teleport.is_of_type(hill_marker) then
            -- Shape
            c_teleport.set_shape_visibility(everyone)

            -- Waypoint
            c_teleport.set_waypoint_visibility(everyone)
            c_teleport.set_waypoint_priority(low)
            c_teleport.set_waypoint_range(0, 20)

            inline: if c_teleport.spawn_sequence == map_areas.middle then
                c_teleport.set_waypoint_text("Middle")

            inline: altif c_teleport.spawn_sequence == map_areas.valley then
                c_teleport.set_waypoint_text("Valley")
            
            inline: altif c_teleport.spawn_sequence == map_areas.hangar then
                c_teleport.set_waypoint_text("Hangar")

            inline: altif c_teleport.spawn_sequence == map_areas.sea_red then
                if c_round == 0 then
                    c_teleport.set_waypoint_text("Sea Red")
                altif c_round != 0 then
                    c_teleport.set_waypoint_text("Sea Blue")
                end

            inline: altif c_teleport.spawn_sequence == map_areas.sea_blue then
                if c_round == 0 then
                    c_teleport.set_waypoint_text("Sea Blue")
                altif c_round != 0 then
                    c_teleport.set_waypoint_text("Sea Red")
                end

            inline: altif c_teleport.spawn_sequence == map_areas.red_base then
                inline: if c_round == 0 then
                    c_teleport.set_waypoint_text("Red Base")
                
                inline: altif c_round != 0 then
                    c_teleport.set_waypoint_text("Blue Base")
                end

            inline: altif c_teleport.spawn_sequence == map_areas.blue_base then
                inline: if c_round == 0 then
                    c_teleport.set_waypoint_text("Blue Base")

                inline: altif c_round != 0 then
                    c_teleport.set_waypoint_text("Red Base")
                end

            inline: altif c_teleport.spawn_sequence == map_areas.centre_island then
                c_teleport.set_waypoint_text("Island")
                
            inline: altif c_teleport.spawn_sequence == map_areas.up then
                c_teleport.set_waypoint_text("Up")
            
            inline: altif c_teleport.spawn_sequence == map_areas.down then
                c_teleport.set_waypoint_text("Down")
            
            inline: altif c_teleport.spawn_sequence == map_areas.down then
                c_teleport.set_waypoint_text("Bottom")
            end
        end
    end
end

-- QoL Teleports.





-- Custom teleports

-- For c_teleport.
alias linked_teleport = object.object[0]

-- For c_biped.
alias saved_teleport = object.object[0]
alias delay = object.number[0]

function initialize_custom_teleport()
    alias c_teleport = current_object

    c_teleport.set_waypoint_range(0, 10)
    c_teleport.set_waypoint_visibility(everyone)
    c_teleport.set_waypoint_priority(low)   

    inline: if c_teleport.is_of_type(hill_marker) then
        c_teleport.set_waypoint_text("Sender")
        c_teleport.set_shape_visibility(everyone)  
                
    inline: altif c_teleport.is_of_type(capture_plate) then
        c_teleport.set_waypoint_text("Reciever")
        c_teleport.set_shape_visibility(no_one)
    end
end

function link_teleports()
    for each object with label "teleporter" do
        alias c_teleport = allocate global.object
        c_teleport = current_object

        inline: if c_teleport.spawn_sequence > 0 then
            inline: if c_teleport.is_of_type(hill_marker) or c_teleport.is_of_type(capture_plate) then
                for each object with label "teleporter" do
                    alias temp_teleport = current_object
    
                    inline: if c_teleport.spawn_sequence > 0 then
                        inline: if temp_teleport.is_of_type(hill_marker) or temp_teleport.is_of_type(capture_plate) then
                            -- If these teleports are not the same one.
                            inline: if c_teleport != temp_teleport then
                                -- If these teleports have to link together.
                                inline: if temp_teleport.spawn_sequence == c_teleport.spawn_sequence then
                                    c_teleport.linked_teleport = temp_teleport
                                    temp_teleport.linked_teleport = c_teleport
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

function custom_teleports()
    link_teleports()

    for each object with label "teleporter" do
        alias c_teleport = current_object

        inline: if c_teleport.spawn_sequence > 0 then
            inline: if c_teleport.is_of_type(hill_marker) or c_teleport.is_of_type(capture_plate) then
                initialize_custom_teleport()
            end

            -- If this teleport has a linked teleport.
            inline: if c_teleport.linked_teleport != no_object then
                -- Main logic
                inline: if c_teleport.is_of_type(hill_marker) then
                    for each player do
                        alias c_player = current_player
                        alias c_biped = allocate global.object
                        c_biped = c_player.biped

                        -- If a player has entered this custom teleport.
                        inline: if c_teleport.shape_contains(c_biped) and c_biped.saved_teleport == no_object then
                            alias c_weapon = allocate global.object
                            c_weapon = c_player.get_weapon(primary)

                            -- If this player has a flag.
                            inline: if c_weapon.is_of_type(flag) then
                                -- If the custom teleport and the flag are from the same team.
                                inline: if c_teleport.team == c_weapon.team then
                                    c_biped.attach_to(c_teleport.linked_teleport, 0, 0, 0, relative)
                                    c_biped.saved_teleport = c_teleport.linked_teleport
                                end

                            -- If this player doesn't have a flag.
                            inline: altif not c_weapon.is_of_type(flag) then
                                c_biped.attach_to(c_teleport.linked_teleport, 0, 0, 0, relative)
                                c_biped.saved_teleport = c_teleport.linked_teleport
                            end
                        end 

                        --If this player has a saved teleport
                        inline: if c_biped.saved_teleport != no_object then
                            -- If this player is not inside the saved teleport's shape.
                            inline: if not c_biped.saved_teleport.shape_contains(c_biped) then
                                c_biped.saved_teleport = no_object
                                c_biped.delay = 0
                            end

                            c_biped.delay += 1

                            inline: if c_biped.delay == 50 then
                                c_biped.detach()
                                c_biped.delay = 0
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Custom teleports





-- Push teleports

-- For c_teleport. 
alias is_blocked = object.number[0]

-- For c_falcon.
alias initialized = object.number[1]
alias is_banned = object.number[2]
alias grace_timer = object.timer[0]

function initialize_falcon()
    alias c_falcon = current_object

    c_falcon.is_banned = 0
    c_falcon.grace_timer = 0
    c_falcon.grace_timer.set_rate(0%)
end

function push_teleports()
    for each object with label "teleporter" do
        alias c_teleport = current_object

        inline: if c_teleport.spawn_sequence == -1 then
            c_teleport.is_blocked = 0

            c_teleport.set_shape(cylinder, 20, 15, 0)
            c_teleport.set_waypoint_range(0, 20)
            c_teleport.set_waypoint_text("Do not block!")
        end
    end

    -- For each falcon do
    for each object with label 1 do
        alias c_falcon = allocate global.object
        c_falcon = current_object

        inline: if c_falcon.initialized == 0 then
            c_falcon.initialized = 1
            initialize_falcon()
        end

        alias is_blocking = allocate global.number
        is_blocking = 0

        for each object with label "teleporter" do
            alias c_teleport = current_object

            inline: if c_teleport.spawn_sequence == -1 and c_teleport.shape_contains(c_falcon) then
                c_falcon.grace_timer.set_rate(100%)
                c_teleport.is_blocked = 1
                is_blocking = 1

                inline: if c_falcon.grace_timer >= 15 or c_falcon.is_banned == 1 then
                    c_falcon.apply_upward_impulse()
                    c_falcon.is_banned = 1
                end
            end
        end

        inline: if is_blocking == 0 then
            c_falcon.grace_timer.set_rate(0%)
            c_falcon.grace_timer = 0
        end
    end

    for each object with label "teleporter" do
        alias c_teleport = current_object

        inline: if c_teleport.spawn_sequence == -1 then
            inline: if c_teleport.is_blocked == 1 then
                c_teleport.set_shape_visibility(everyone)
                c_teleport.set_waypoint_priority(blink)
                c_teleport.set_waypoint_visibility(everyone)

            inline: altif c_teleport.is_blocked == 0 then
                c_teleport.set_shape_visibility(no_one)
                c_teleport.set_waypoint_priority(normal)
                c_teleport.set_waypoint_visibility(no_one)
            end
        end
    end
end

-- Push teleports





-- Blinkshot

-- For blink_spawn
alias blinkshot = object.object[0]

-- For c_player
alias blinkshot = player.object[0]

-- For killed_blink
alias delay = object.number[0]

function blinkshot()
    for each object with label "blink_spawn" do
        alias blink_spawn = current_object

        inline: if blink_spawn.blinkshot == no_object then
            blink_spawn.blinkshot = blink_spawn.place_at_me(monitor, "blinkshot", none, 0, 0, 0, none)
            blink_spawn.blinkshot.set_scale(150)
            blink_spawn.blinkshot.set_waypoint_priority(low)
            blink_spawn.blinkshot.set_waypoint_visibility(everyone)
            blink_spawn.blinkshot.set_waypoint_range(0, 100)
        end
    end

    for each object with label "blinkshot" do
        alias blinkshot = current_object
        blinkshot.shields = 0
        blinkshot.health = 1
    end

    for each player do
        alias c_player = current_player
        alias killed_blink = allocate global.object
        killed_blink = c_player.blinkshot

        inline: if killed_blink != no_object and killed_blink.has_forge_label("blinkshot") then
            alias c_weapon = allocate global.object
            c_weapon = c_player.get_weapon(primary)

            inline: if c_weapon.is_of_type(flag) then
                killed_blink.delete()
            end

            c_player.biped.attach_to(killed_blink, 0, 0, 0, relative)
            c_player.biped.shields = 0

            killed_blink.delay += 1
            inline: if killed_blink.delay >= 40 then
                c_player.biped.detach()
                killed_blink.delete()
            end
        end
    end
end

-- Blinkshot





-- Betrayers handler

alias betrayals = player.number[2]

function betrayers()
    for each player do
        alias c_player = current_player

        -- If the current player was killed by a teammate
        inline: if c_player.killer_type_is(betrayal) then 
            -- Save the betrayer on a global player
            global.player[5] = c_player.try_get_killer()

            inline: if c_player.betrayals < 3 then 
                -- Increase the betrayals of the betrayer
                global.player[5].betrayals += 1

                -- If the betrayer betrayals is less than 4
                inline: if global.player[5].betrayals < 4 then 
                    game.show_message_to(all_players, none, "Teamkilling is not allowed, %n!", global.player[5])
                end

                inline: if global.player[5].betrayals >= 4 then 
                    global.player[5].biped.set_waypoint_text("Betrayer")
                    global.player[5].biped.set_waypoint_visibility(everyone)

                    -- Warn all the players
                    game.show_message_to(all_players, none, "%n has been penalized for teamkilling", global.player[5])
                end
            end
        end

        inline: if c_player.betrayals == 4 then 
            -- Apply the punishment
            c_player.apply_traits(script_traits[3])

            c_player.biped.remove_weapon(primary, true)
            c_player.biped.remove_weapon(secondary, true)
            
            c_player.frag_grenades = 0
            c_player.plasma_grenades = 0
        end
    end
end

-- Betrayer handler





-- Comms.

-- For comms.
alias linked_comms = object.object[0]
alias instance = object.object[1]

function link_comms()
    for each object with label "comms_spawn" do
        alias c_comms = allocate global.object
        c_comms = current_object

        inline: if c_comms.is_of_type(hill_marker) then
            for each object with label "comms_spawn" do
                alias temp_comms = current_object
    
                inline: if temp_comms.is_of_type(hill_marker) then
                    -- If these comms spawns are not the same one.
                    inline: if c_comms != temp_comms then
                        -- If these comms spawns have to link together.
                        inline: if c_comms.spawn_sequence == temp_comms.spawn_sequence then
                            c_comms.linked_comms = temp_comms
                            temp_comms.linked_comms = c_comms
                        end
                    end
                end
            end
        end
    end
end

function comms()
    link_comms()

    for each object with label "comms_spawn" do
        alias c_comms = current_object

        -- If the comms team is red team.
        inline: if c_comms.team == team[0] then
            -- If is a hill marker and doesnt have a saved comms instance.
            inline: if c_comms.is_of_type(hill_marker) and c_comms.instance == no_object then
                c_comms.instance = c_comms.place_at_me(monitor, "comms", none, 0, 0, 0, none)
        
                -- Initialize comms.
                c_comms.instance.remove_weapon(primary, true)
                c_comms.instance.set_waypoint_visibility(everyone)
                c_comms.instance.set_waypoint_text("Comms")
                c_comms.instance.set_waypoint_priority(low)
                c_comms.instance.set_waypoint_range(0, 50)
                c_comms.instance.set_scale(100)
            end
        
        inline: altif c_comms.team == team[1] and c_comms.is_of_type(hill_marker) then
            c_comms.set_shape(cylinder, 40, 20, 10)
            c_comms.set_shape_visibility(everyone)            
        end
    
        -- If the instance exists and is a monitor.
        inline: if c_comms.instance != no_object and c_comms.instance.is_of_type(monitor) then
            c_comms.instance.shields = 0
            c_comms.instance.health = 1

            -- If the instance is outside the comms spawn shape.
            inline: if not c_comms.shape_contains(c_comms.instance) then
                -- Restore its initial position.
                c_comms.instance.attach_to(c_comms, 0, 0, 0, relative)
                c_comms.instance.detach()
            end
        end
    end
end

-- Comms.





-- MVP.

declare global.player[2] with network priority low
alias mvp = global.player[2]

function mvp()
    for each player do
        alias c_player = current_player

        if mvp == no_player then
            mvp = c_player
        end

        if c_player.rating > mvp.rating and c_player != mvp then
            game.show_message_to(all_players, none, "%n is the current MVP!", c_player)
            mvp = c_player
        end
    end
end

-- MVP.





-- Captains. TODO

alias captain = team.player[0]

function captains()
    for each team do
        alias c_team = current_team

        if c_team.number[0] == 0 and c_team == team[0] then
            c_team.number[0] = 1
            
            for each player randomly do
                alias c_player = current_player
                c_team.captain = c_player
            end

            game.show_message_to(all_players, none, "%n is a team captain!", c_team.captain)
        end

        for each player do
            alias c_player = allocate global.player
            c_player = current_player

            -- If this is the captain of the current team.
            if c_player == c_team.captain then
                
                for each player do
                    alias temp_player = current_player
                    
                    if temp_player != c_player then
                        temp_player.biped.set_waypoint_visibility(mod_player, c_team.captain, 1)
                    end
                end
            end
        end
    end
end

-- Captains.





-- Main.
on init: do
    qol_teleports()
end

do
    scaling_system()
    custom_teleports()
    push_teleports()
    qol_falcon()
    blinkshot()
    betrayers()
    comms()
    mvp()
    --captains()
end

on object death: do
    --game.show_message_to(all_players, none, "Object killed")

    -- If the killer was a player.
    inline: if killer_player != no_player then
        alias c_vehicle = allocate global.object
        c_vehicle = killer_player.get_vehicle()

        -- If the player didn't had a vehicle.
        inline: if c_vehicle == no_object then
            -- If a blink was killed.
            inline: if killed_object.has_forge_label("blinkshot") then
                killer_player.blinkshot = killed_object.place_at_me(hill_marker, "blinkshot", none, 0, 0, 0, none)
            
            -- If a comms instance was killed.
            inline: altif killed_object.has_forge_label("comms") then
                for each object with label "comms_spawn" do
                    alias c_comms = current_object

                    -- If this is a collector comms and its instance was killed.
                    inline: if c_comms.team == team[0] and c_comms.instance == no_object then
                        alias available = allocate global.number
                        available = 0

                        alias linked_comms = allocate global.object
                        linked_comms = c_comms.linked_comms

                        inline: if linked_comms != no_object and linked_comms.team == team[1] then
                            for each object with label 1 do
                                alias c_falcon = current_object
                                alias c_health = allocate global.number
                                c_health = c_falcon.health

                                inline: if linked_comms.shape_contains(c_falcon) and c_health > 0 then
                                    available += 1
                                end
                            end
                        end

                        inline: if available >= 1 then
                            game.show_message_to(killer_player, none, "Available falcons: %n", available)
                            
                        inline: altif available == 0 then
                            game.show_message_to(killer_player, none, "There are no falcons")
                        end
                    end
                end
            end
        end
    end
end
-- Main.





-- Capture the flag

enum sides
   multi
   one
   neutral
end

alias opt_flag_return_time     = script_option[0]
alias opt_flag_reset_time      = script_option[1]
alias opt_sides                = script_option[2] -- see (sides) enum
alias opt_flag_at_home         = script_option[3]
alias opt_carrier_cooldown     = script_option[4]
alias opt_flag_preserve_radius = script_option[5] -- range option; not visible in UI; defaults to 20
alias opt_lead_to_win          = script_option[6] -- Lead to win
-- script_option[5] is an unused range option; not visible in UI; defaults to 7

-- Unnamed Forge labels:
alias all_flags = 0

alias carrier_traits  = script_traits[0]
alias cooldown_traits = script_traits[1]

alias ui_return_flag_to_score = script_widget[0]

alias captures   = player.script_stat[0]
alias carry_time = player.script_stat[1]
alias returns    = player.script_stat[2]

enum flag_state
   at_home
   carried
   dropped
end

alias sudden_death_enabled        = global.number[0]
alias announced_sudden_death      = global.number[1]
alias any_flag_is_being_preserved = global.number[2] -- is set, but nothing ever uses it

alias announced_game_start       = player.number[0]
alias is_returning_flag          = player.number[1]
alias carrier_cooldown_timer     = player.timer[0]
alias carry_time_update_interval = player.timer[1]
alias announce_start_timer       = player.timer[2]

alias state                 = object.number[0] -- flag state; see (flag_state) enum
alias announced_flag_take   = object.number[2]
alias announced_flag_drop   = object.number[3]
alias preserve_zone         = object.object[0] -- boundary centered on flag; enemies inside prevent flag from resetting (One Flag)
alias last_carrier          = object.player[0]
alias reset_timer           = object.timer[0]
alias return_timer          = object.timer[1]
alias notification_throttle = object.timer[2]

alias flag_point = team.object[0] -- spawn and drop point
alias flag       = team.object[1]

declare sudden_death_enabled   with network priority local
declare announced_sudden_death with network priority local
declare any_flag_is_being_preserved with network priority low
declare global.number[3] with network priority local
declare global.number[4] with network priority local
declare global.object[0] with network priority local
declare global.object[1] with network priority local
declare global.player[0] with network priority local
declare global.player[1] with network priority local
declare global.team[0] with network priority local

declare player.announced_game_start with network priority low
declare player.is_returning_flag with network priority low
declare player.carry_time_update_interval = 1
declare player.announce_start_timer = 5

declare object.state with network priority low
declare object.number[1] with network priority low = 1 -- unused
declare object.announced_flag_take with network priority local
declare object.announced_flag_drop with network priority local
declare object.preserve_zone with network priority low
declare object.last_carrier  with network priority low
declare object.reset_timer  = opt_flag_reset_time
declare object.return_timer = opt_flag_return_time
declare object.notification_throttle = 3

declare team.flag_point with network priority low
declare team.flag       with network priority low

do
    sudden_death_enabled = 0
end

on pregame: do
    game.symmetry = 1
    if opt_sides == sides.one then 
        game.symmetry = 0
    end
end

----------------------------------------
-- LOADOUT PALETTES
----------------------------------------
for each player do
    if current_player.is_elite() then 
        current_player.set_loadout_palette(elite_tier_1)
    end

    if not current_player.is_elite() then 
        current_player.set_loadout_palette(spartan_tier_1)
    end
end

----------------------------------------
-- ROUND CARD
----------------------------------------
for each player do
    current_player.announce_start_timer.set_rate(-100%)

    if opt_sides == sides.one and current_player.team == team[1] then 
        current_player.set_objective_text("Capture the enemy flag.\r\n%n rounds.", game.round_limit)
        current_player.set_objective_allegiance_name("Offense")
        current_player.set_objective_allegiance_icon(attack)
    end

    if opt_sides == sides.one and current_player.team == team[0] then 
        current_player.set_objective_text("Defend your flag.\r\n%n rounds.", game.round_limit)
        current_player.set_objective_allegiance_name("Defense")
        current_player.set_objective_allegiance_icon(defend)
    end

    if game.score_to_win != 0 and opt_sides == sides.neutral or opt_sides == sides.multi then 
        if opt_lead_to_win > 0 then -- Lead to win
            current_player.set_objective_text("Capture the flag.\r\n%n point lead or %n points to win.", opt_lead_to_Win, game.score_to_win)
        end
        
        if opt_lead_to_win == 0 then
            current_player.set_objective_text("Capture the flag.\r\n%n points to win.", game.score_to_win)
        end
    end

    if game.score_to_win == 0 and opt_sides == sides.neutral or opt_sides == sides.multi then 
        if opt_lead_to_win > 0 then -- Lead to win
            current_player.set_objective_text("Capture the flag.\r\n%n point lead to win.", opt_lead_to_win)
        end

        if opt_lead_to_win == 0 then
            current_player.set_objective_text("Capture the flag.")
        end
    end
end

----------------------------------------
-- GAME ANNOUNCES: set up UI and announce game start.
----------------------------------------
for each player do 
    ui_return_flag_to_score.set_text("Your flag must be at home to score!")
    ui_return_flag_to_score.set_visibility(current_player, false)

    if current_player.announced_game_start == 0 and current_player.announce_start_timer.is_zero() then 
        send_incident(ctf_game_start, current_player, no_player)
        current_player.announced_game_start = 1

        if opt_sides == sides.one and current_player.team == team[1] then 
            send_incident(team_offense, current_player, no_player)
        end
        
        if opt_sides == sides.one and current_player.team == team[0] then 
            send_incident(team_defense, current_player, no_player)
        end
    end
end

----------------------------------------
-- SETUP FLAGS DROP POINTS: initial setup for flag spawn/drop point.
----------------------------------------
for each team do 
    if current_team.flag_point == no_object then 
        for each object with label "ctf_flag_return" do
            if  current_team.flag_point == no_object 
                and current_object.team == current_team 
            then 
                current_team.flag_point = current_object
                current_object.set_waypoint_visibility(allies)
                current_object.set_waypoint_icon(diamond)
            end
        end
    end
end

----------------------------------------
-- SETUP FLAG INSTANCES: spawn flags as needed.
----------------------------------------
for each team do 
    current_team.flag.set_waypoint_visibility(everyone)

    if  current_team == neutral_team
        or  current_team.has_any_players()
        and current_team.flag == no_object
        and current_team.flag_point != no_object
    then
        alias should_spawn_flag = global.number[3]
        should_spawn_flag = 0

        if  opt_sides == sides.multi 
            and current_team != neutral_team 
            and current_team.has_any_players() 
        then 
            should_spawn_flag = 1
        end

        if opt_sides == sides.one and current_team == team[0] then 
            team[1].flag_point.set_waypoint_visibility(everyone)
            team[0].flag_point.set_waypoint_visibility(no_one)
            should_spawn_flag = 1
        end

        if opt_sides == sides.neutral and current_team == neutral_team then 
            should_spawn_flag = 1
        end

        if should_spawn_flag == 1 then 
            if opt_sides == sides.one or opt_sides == sides.neutral then
                --
                -- If this is One Flag or Neutral Flag, see if there is an existing flag
                -- and if so, take ownership of it.
                --
                for each object do
                    if current_object.is_of_type(flag) then 
                        current_team.flag = current_object
                        should_spawn_flag = 0
                    end
                end
            end

            if opt_sides == sides.multi then
                --
                -- If this is Multi Flag and the flag somehow tests as unowned, take
                -- ownership of it.
                --
                for each object do
                    if current_object.is_of_type(flag) and should_spawn_flag == 1 then 
                        alias is_unowned = global.number[4]
                        alias current_carrier = global.player[1]
                        is_unowned = 1

                        do -- check if flag carrier is on this team
                            current_carrier = no_player
                            current_carrier = current_object.try_get_carrier()
                            if  current_carrier != no_player 
                                and current_carrier.team == current_team then 
                                is_unowned = 0 -- don't take ownership of an enemy flag being carried by one of our players
                            end
                        end

                        for each team do
                            if current_team.flag == current_object then 
                                is_unowned = 0
                            end
                        end

                        if is_unowned == 1 then 
                            current_team.flag = current_object
                            should_spawn_flag = 0
                        end
                    end
                end
            end

            if should_spawn_flag == 1 then 
                current_team.flag = current_team.flag_point.place_at_me(flag, none, never_garbage_collect, 0, 0, 3, none)
            end
            
            alias current_flag = global.object[0]
            current_flag = current_team.flag

            if should_spawn_flag == 0 then 
                current_flag.state = flag_state.carried
            end

            current_flag.team = current_team
            current_team.flag.set_pickup_permissions(enemies)
            current_team.flag.set_weapon_pickup_priority(high)
            current_team.flag.set_waypoint_icon(flag)
            current_team.flag.set_waypoint_priority(high)
            current_flag.set_shape(cylinder, 7, 6, 3)

            if opt_sides == sides.neutral then 
                current_team.flag.set_pickup_permissions(everyone)
            end
        end
    end
end

----------------------------------------
-- CLEAR PLAYER WAYPOINTS: clear scripted player waypoints.
----------------------------------------
for each player do 
    current_player.biped.set_waypoint_icon(none)
end

----------------------------------------
-- PROCESS FLAG STATES: manage flag carrier, flag state, flag waypoint, flag captures, etc.
----------------------------------------
for each team do 
    alias current_flag = global.object[0]
    alias flag_carrier = global.player[1]
    
    current_flag = current_team.flag
    flag_carrier = no_player
    any_flag_is_being_preserved = 0
    flag_carrier = current_flag.get_carrier()

    -- remember flag carrier, confer traits, and track carry time
    if flag_carrier != no_player then 
        current_flag.last_carrier = flag_carrier
        flag_carrier.apply_traits(carrier_traits)
        flag_carrier.carry_time_update_interval.set_rate(-100%)
        if flag_carrier.carry_time_update_interval.is_zero() then 
            flag_carrier.carry_time += 1
            flag_carrier.carry_time_update_interval.reset()
        end
    end

    -- manage carried flag: waypoint, state, capture check
    if flag_carrier != no_player then 
        alias carrier_team = global.team[0]
        
        current_flag.set_waypoint_visibility(no_one)
        flag_carrier.biped.set_waypoint_icon(flag)
        current_flag.state = flag_state.carried
        current_flag.reset_timer = opt_flag_reset_time
        current_flag.return_timer = opt_flag_return_time
        current_flag.set_progress_bar(0, no_one)
        sudden_death_enabled = 1
        flag_carrier.carrier_cooldown_timer = opt_carrier_cooldown
        carrier_team = flag_carrier.team

        -- handle flag capture
        if carrier_team.flag_point.shape_contains(flag_carrier.biped) then 
            alias capture_is_allowed = global.number[3]
            alias carrier_team_flag  = global.object[1]
            
            capture_is_allowed = 1
            ui_return_flag_to_score.set_visibility(flag_carrier, false)
            -- enforce Flag At Home
            if opt_flag_at_home == 1 and opt_sides == sides.multi then 
                carrier_team_flag = carrier_team.flag
                if carrier_team_flag.state != flag_state.at_home then 
                    capture_is_allowed = 0
                    ui_return_flag_to_score.set_visibility(flag_carrier, true)
                end
            end

            if capture_is_allowed == 1 then 
                flag_carrier.score += 1
                flag_carrier.captures += 1
                current_team.flag.delete()
                send_incident(flag_scored, flag_carrier, all_players)

                if opt_lead_to_win > 0 then -- Lead to win
                    alias is_odd = allocate global.number
                    alias lead_score = allocate global.number
                    is_odd = game.current_round
                    is_odd %= 2
                    lead_score = team[0].score
                    lead_score -= team[1].score

                    if lead_score > 0 then
                        if is_odd == 0 then
                            game.show_message_to(all_players, none, "Red team has a %n point lead!", lead_score)
                        end

                        if is_odd != 0 then
                            game.show_message_to(all_players, none, "Blue team has a %n point lead!", lead_score)
                        end

                        if lead_score >= opt_lead_to_win then
                            game.end_round()
                        end
                    end

                    lead_score = team[1].score
                    lead_score -= team[0].score

                    if lead_score > 0 then
                        if is_odd == 0 then
                            game.show_message_to(all_players, none, "Blue team has a %n point lead!", lead_score)
                        end

                        if is_odd != 0 then
                            game.show_message_to(all_players, none, "Red team has a %n point lead!", lead_score)
                        end

                        if lead_score >= opt_lead_to_win then
                            game.end_round()
                        end
                    end
                end
            end
        end
    end

    -- flag was just dropped
    if flag_carrier == no_player and current_flag.state == flag_state.carried then 
        current_flag.state = flag_state.dropped

        if opt_flag_return_time != 1 then 
            current_flag.set_progress_bar(1, allies)
        end

        current_flag.set_waypoint_icon(flag)
        current_flag.set_waypoint_visibility(everyone)
        current_team.flag.set_waypoint_priority(high)
    end
end

----------------------------------------
-- PROCESS FLAG RECOVERY: handle flag returns and resets.
----------------------------------------
for each team do 
    alias current_flag = global.object[0]
    current_flag = current_team.flag

    if  current_flag != no_object 
        and current_flag.state == flag_state.dropped 
        or current_flag.state == 3 
    then 
        current_flag.reset_timer.set_rate(-100%)
        current_flag.return_timer.set_rate(100%)

        --
        -- Identify players returning the flag:
        --
        for each player do
            current_player.is_returning_flag = 0
            if current_player.team == current_team and current_flag.shape_contains(current_player.biped) then 
                current_player.is_returning_flag = 1
                current_flag.return_timer.set_rate(-100%)

                if opt_flag_return_time == 1 then 
                    current_flag.return_timer.set_rate(-1000%)
                end

                -- blink the flag's waypoint if it's being returned
                current_flag.set_waypoint_priority(blink) 
            end
        end
        
        -- blink the flag's waypoint when it's about to reset
        for each object with label all_flags do 
            if current_object.reset_timer < 6 then 
                current_object.set_waypoint_priority(blink)
            end
        end

        --
        -- Carry out resets and returns as appropriate:
        --
        if  current_flag.is_out_of_bounds() 
            or current_flag.reset_timer.is_zero() 
        then -- carry out the reset
            current_flag.delete()

            if opt_sides == sides.neutral then 
                send_incident(flag_reset_neutral, current_flag.last_carrier, current_team)
            end

            if opt_sides != sides.neutral then 
                send_incident(flag_reset, current_team, current_team)
            end
        end

        -- carry out the return
        if current_flag.return_timer.is_zero() then 
            current_flag.delete()
            send_incident(flag_recovered, current_team, current_team)
            -- credit players for returning flags
            for each player do 
                if current_player.is_returning_flag == 1 and current_player.team == current_team then 
                    current_player.returns += 1
                    current_player.is_returning_flag = 0
                end
            end
        end
    end
end

----------------------------------------
-- PROCESS FLAG NOTIFICATIONS: send incidents for the flag being taken or dropped.
----------------------------------------
for each team do 
    alias current_flag    = global.object[0]
    alias current_carrier = global.player[1]
    alias carrier_biped   = global.object[1]
    
    current_flag    = current_team.flag
    carrier_biped   = current_flag.last_carrier.biped
    current_carrier = current_flag.last_carrier
    current_flag.notification_throttle.set_rate(-100%)

    if current_flag.notification_throttle.is_zero() then 
        if  current_flag.state == flag_state.dropped 
            and current_flag.announced_flag_drop != 1 
        then 
            current_flag.announced_flag_drop = 1
            
            if opt_sides == sides.neutral then 
                send_incident(flag_dropped_neutral, current_flag.last_carrier, current_team)
            end

            if opt_sides != sides.neutral then 
                send_incident(flag_dropped, current_flag.last_carrier, current_team)
            end

            current_flag.notification_throttle.reset()
        end

        if  current_flag.state == flag_state.carried 
            and current_flag.announced_flag_take != 1 
        then 
            current_flag.announced_flag_take = 1

            if opt_sides == sides.neutral then 
                send_incident(flag_grabbed_neutral, current_carrier, current_team)
            end

            if opt_sides != sides.neutral then 
                send_incident(flag_grabbed, current_carrier, current_team)
            end

            current_flag.notification_throttle.reset()
        end

        if current_flag.state != flag_state.carried then 
            current_flag.announced_flag_take = 0
        end

        if  current_flag.state == flag_state.carried 
            or current_flag.state == flag_state.at_home 
        then 
            current_flag.announced_flag_drop = 0
        end
    end
end

----------------------------------------
-- MANAGE CARRIER COOLDOWN: carrier cooldown traits.
----------------------------------------
for each player do 
    alias current_biped  = global.object[0]
    alias current_weapon = global.object[1]
    current_biped = current_player.biped

    if not current_biped == no_object then 
        current_weapon = no_object
        current_weapon = current_player.get_weapon(primary)
        
        if  not current_weapon.is_of_type(flag) 
            and current_player.carrier_cooldown_timer > 0 
        then 
            current_player.carrier_cooldown_timer.set_rate(-100%)

            if not current_player.carrier_cooldown_timer.is_zero() then 
                current_player.apply_traits(cooldown_traits)
            end
        end
    end
end

----------------------------------------
-- HANDLE CARRIER DEATH: handle the carrier being killed.
----------------------------------------
for each team do 
    alias current_flag = global.object[0]
    alias killer       = global.player[0]
    
    if current_team.has_any_players() then 
        current_flag = current_team.flag

        for each player do
            if current_flag.last_carrier.killer_type_is(kill) then 
                killer = current_flag.last_carrier.try_get_killer()
                send_incident(flagcarrier_kill, killer, current_flag.last_carrier)
                current_flag.last_carrier = no_player
            end
        end
    end
end

----------------------------------------
-- INITIALIZE FLAG PROXIMITY ZONES: create a preserve boundary for each flag.
----------------------------------------
for each object with label all_flags do 
    if current_object.preserve_zone == no_object then 
        current_object.preserve_zone = current_object.place_at_me(hill_marker, none, never_garbage_collect | suppress_effect, 0, 0, 0, none)
        current_object.preserve_zone.set_shape(cylinder, opt_flag_preserve_radius, 10, 10)
        current_object.preserve_zone.set_shape_visibility(no_one)
        current_object.preserve_zone.attach_to(current_object, 0, 0, 0, relative)
    end
end

----------------------------------------
-- PROCESS FLAG PRESERVATION: handle preserve boundaries (One Flag).
----------------------------------------
for each object with label all_flags do 
    alias current_flag = global.object[0]
    
    if opt_sides == sides.one then 
        current_flag = current_object

        for each player do
            if  current_player.team != current_flag.team
                and current_flag.preserve_zone.shape_contains(current_player.biped) 
            then 
                any_flag_is_being_preserved = 1
                current_flag.reset_timer.set_rate(0%)
            end
        end
    end
end

----------------------------------------
-- CLEANUP FLAG CARRIER REFERENCES: detect a flag being dropped (clear last_carrier when no longer carried).
----------------------------------------
for each object with label all_flags do 
    alias current_flag    = global.object[0]
    alias current_carrier = global.player[1]
    current_flag = current_object

    if current_flag.last_carrier != no_player then 
        for each player do
            if current_player == current_flag.last_carrier then 
                current_carrier = no_player
                current_carrier = current_flag.get_carrier()

                if current_carrier == no_player then 
                    current_flag.last_carrier = no_player
                end
            end
        end
    end
end

----------------------------------------
-- UPDATE DYNAMIC SPAWN ZONES: manage CTF spawn zones.
----------------------------------------
for each team do 
    alias current_flag = global.object[0]
    
    if current_team.has_any_players() then 
        current_flag = current_team.flag
        
        if not current_flag == no_object then 
            for each object with label "ctf_res_zone" do
                if current_object.team == current_team then 
                    current_object.enable_spawn_zone(0)
                    current_object.set_shape_visibility(no_one)
                    current_object.set_invincibility(1)
                    current_object.set_pickup_permissions(no_one)

                    if current_flag.state == flag_state.at_home then 
                        current_object.enable_spawn_zone(1)
                    end
                end
            end

            for each object with label "ctf_res_zone_away" do
                if current_object.team == current_team then 
                    current_object.enable_spawn_zone(0)
                    current_object.set_shape_visibility(no_one)
                    current_object.set_invincibility(1)
                    current_object.set_pickup_permissions(no_one)
                    
                    if current_flag.state != flag_state.at_home then 
                        current_object.enable_spawn_zone(1)
                    end
                end
            end
        end
    end
end

----------------------------------------
-- CLEANUP EMPTY TEAM FLAGS: delete a team's flag if all of their players quit and their flag is at home.
----------------------------------------
for each team do 
    alias current_flag = global.object[0]
    
    if  current_team != neutral_team 
        and not current_team.has_any_players() 
        and current_team.flag != no_object 
    then 
        current_flag = current_team.flag

        if current_flag.state == flag_state.at_home then 
            current_team.flag.delete()
            current_team.flag = no_object
        end
    end
end

----------------------------------------
-- MANAGE ROUND TERMINATION
----------------------------------------
-- Manage round timer:
if not game.round_timer.is_zero() then 
    game.grace_period_timer = 0
end

if game.round_time_limit > 0 then 
    if not game.round_timer.is_zero() then 
        announced_sudden_death = 0
    end

    if game.round_timer.is_zero() then 
        if sudden_death_enabled == 1 then 
            game.sudden_death_timer.set_rate(-100%)
            game.grace_period_timer.reset()

            if announced_sudden_death == 0 then 
                send_incident(sudden_death, all_players, all_players)
                announced_sudden_death = 1
            end

            if  game.sudden_death_time > 0 
                and game.grace_period_timer > game.sudden_death_timer 
            then 
                game.grace_period_timer = game.sudden_death_timer
            end
        end

        if sudden_death_enabled == 0 then 
            game.grace_period_timer.set_rate(-100%)

            if game.grace_period_timer.is_zero() then 
                game.end_round()
            end
        end
        
        if game.sudden_death_timer.is_zero() then 
            game.end_round()
        end
    end
end

-- Capture the flag